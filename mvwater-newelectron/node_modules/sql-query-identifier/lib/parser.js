'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _tokenizer = require('./tokenizer');

/**
 * Execution types allow to know what is the query behavior
 *  - LISTING: is when the query list the data
 *  - MODIFICATION: is when the query modificate the database somehow (structure or data)
 *  - INFORMATION: is show some data information such as a profile data
 *  - UNKNOWN
 */
var EXECUTION_TYPES = {
  SELECT: 'LISTING',
  INSERT: 'MODIFICATION',
  DELETE: 'MODIFICATION',
  UPDATE: 'MODIFICATION',
  CREATE_DATABASE: 'MODIFICATION',
  CREATE_TABLE: 'MODIFICATION',
  DROP_DATABASE: 'MODIFICATION',
  DROP_TABLE: 'MODIFICATION',
  TRUNCATE: 'MODIFICATION',
  UNKNOWN: 'UNKNOWN'
};

/**
 * Parser
 */
function parse(input) {
  var isStrict = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

  var topLevelState = initState({ input: input });
  var topLevelStatement = {
    type: 'QUERY',
    start: 0,
    end: input.length - 1,
    body: [],
    tokens: []
  };

  var prevState = topLevelState;
  var statementParser = void 0;

  var ignoreOutsideBlankTokens = ['whitespace', 'comment-inline', 'comment-block'];

  while (prevState.position < topLevelState.end) {
    var tokenState = initState({ prevState: prevState });
    var token = (0, _tokenizer.scanToken)(tokenState);

    if (!statementParser) {
      // ignore blank tokens that are not in a statement
      if (~ignoreOutsideBlankTokens.indexOf(token.type)) {
        topLevelStatement.tokens.push(token);
        prevState = tokenState;
        continue;
      }

      statementParser = createStatementParserByToken(isStrict, token);
    }

    statementParser.addToken(token);
    topLevelStatement.tokens.push(token);
    prevState = tokenState;

    var statement = statementParser.getStatement();
    if (statement.endStatement) {
      statement.end = token.end;
      topLevelStatement.body.push(statement);
      statementParser = null;
    }
  }

  // last statement without ending key
  if (statementParser) {
    var _statement = statementParser.getStatement();
    if (!_statement.endStatement) {
      _statement.end = topLevelStatement.end;
      topLevelStatement.body.push(_statement);
    }
  }

  return topLevelStatement;
}

function initState(_ref) {
  var input = _ref.input;
  var prevState = _ref.prevState;

  if (prevState) {
    return {
      input: prevState.input,
      position: prevState.position,
      start: prevState.position + 1,
      end: prevState.input.length - 1,
      body: []
    };
  }

  return {
    input: input,
    position: -1,
    start: 0,
    end: input.length - 1,
    body: []
  };
}

function createStatementParserByToken(isStrict, token) {
  if (token.type === 'keyword') {
    switch (token.value.toUpperCase()) {
      case 'SELECT':
        return createSelectStatementParser(isStrict);
      case 'CREATE':
        return createCreateStatementParser(isStrict);
      case 'DROP':
        return createDropStatementParser(isStrict);
      case 'INSERT':
        return createInsertStatementParser(isStrict);
      case 'UPDATE':
        return createUpdateStatementParser(isStrict);
      case 'DELETE':
        return createDeleteStatementParser(isStrict);
      case 'TRUNCATE':
        return createTruncateStatementParser(isStrict);
      default:
        break;
    }
  }

  if (!isStrict && token.type === 'unknown') {
    return createUnknownStatementParser(isStrict);
  }

  throw new Error('Invalid statement parser "' + token.value + '"');
}

function createSelectStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Select
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'SELECT' }]
    },
    add: function add(token) {
      statement.type = 'SELECT';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createInsertStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Insert
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'INSERT' }]
    },
    add: function add(token) {
      statement.type = 'INSERT';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createUpdateStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Update
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'UPDATE' }]
    },
    add: function add(token) {
      statement.type = 'UPDATE';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createDeleteStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Delete
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'DELETE' }]
    },
    add: function add(token) {
      statement.type = 'DELETE';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createCreateStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Create
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'CREATE' }]
    },
    add: function add(token) {
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  },
  // Table/Database
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      requireBefore: ['whitespace'],
      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]
    },
    add: function add(token) {
      statement.type = 'CREATE_' + token.value.toUpperCase();
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createDropStatementParser(isStrict) {
  var statement = {};

  var steps = [
  // Drop
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'DROP' }]
    },
    add: function add(token) {
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  },
  // Table/Database
  {
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      requireBefore: ['whitespace'],
      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]
    },
    add: function add(token) {
      statement.type = 'DROP_' + token.value.toUpperCase();
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createTruncateStatementParser(isStrict) {
  var statement = {};

  var steps = [{
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    validation: {
      acceptTokens: [{ type: 'keyword', value: 'TRUNCATE' }]
    },
    add: function add(token) {
      statement.type = 'TRUNCATE';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function createUnknownStatementParser(isStrict) {
  var statement = {};

  var steps = [{
    preCanGoToNext: function preCanGoToNext() {
      return false;
    },
    add: function add(token) {
      statement.type = 'UNKNOWN';
      statement.start = token.start;
    },
    postCanGoToNext: function postCanGoToNext() {
      return true;
    }
  }];

  return stateMachineStatementParser(isStrict, statement, steps);
}

function stateMachineStatementParser(isStrict, statement, steps) {
  var currentStepIndex = 0;
  var prevToken = void 0;

  /* eslint arrow-body-style: 0, no-extra-parens: 0 */
  var isValidToken = function isValidToken(step, token) {
    if (!step.validation) {
      return true;
    }

    return step.validation.acceptTokens.filter(function (accept) {
      var isValidType = token.type === accept.type;
      var isValidValue = !accept.value || token.value.toUpperCase() === accept.value;

      return isValidType && isValidValue;
    }).length > 0;
  };

  var hasRequiredBefore = function hasRequiredBefore(step) {
    return !step.requireBefore || ~step.requireBefore.indexOf(prevToken.type);
  };

  return {
    getStatement: function getStatement() {
      return statement;
    },
    addToken: function addToken(token) {
      /* eslint no-param-reassign: 0 */
      if (statement.endStatement) {
        throw new Error('This statement has already got to the end.');
      }

      if (token.type === 'semicolon') {
        statement.endStatement = ';';
        return;
      }

      if (token.type === 'whitespace') {
        prevToken = token;
        return;
      }

      if (statement.type) {
        // statement has already been identified
        // just wait until end of the statement
        return;
      }

      var currentStep = steps[currentStepIndex];
      if (currentStep.preCanGoToNext(token)) {
        currentStepIndex++;
        currentStep = steps[currentStepIndex];
      }

      if (!hasRequiredBefore(currentStep)) {
        var requireds = currentStep.requireBefore.join(' or ');
        throw new Error('Expected any of these tokens ' + requireds + ' before "' + token.value + '" (currentStep=' + currentStepIndex + ').');
      }

      if (!isValidToken(currentStep, token) && isStrict) {
        var expecteds = currentStep.validation.acceptTokens.map(function (accept) {
          return '(type="' + accept.type + '" value="' + accept.value + '")';
        }).join(' or ');
        throw new Error('Expected any of these tokens ' + expecteds + ' instead of type="' + token.type + '" value="' + token.value + '" (currentStep=' + currentStepIndex + ').');
      }

      currentStep.add(token);

      statement.executionType = EXECUTION_TYPES[statement.type] || 'UNKNOWN';

      if (currentStep.postCanGoToNext(token)) {
        currentStepIndex++;
      }

      prevToken = token;
    }
  };
}